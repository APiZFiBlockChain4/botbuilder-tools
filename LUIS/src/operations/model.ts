/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/mappers";
import { LuisAuthoring } from "../luisAuthoring";

const WebResource = msRest.WebResource;

/** Class representing a Model. */
export class Model {
  private readonly client: LuisAuthoring;
  /**
   * Create a Model.
   * @param {LuisAuthoring} client Reference to the service client.
   */
  constructor(client: LuisAuthoring) {
    this.client = client;
  }

  /**
   * Adds an intent classifier to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelCreateObject} intentCreateObject A model object containing the
   * name of the new intent classifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addIntentWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (intentCreateObject === null || intentCreateObject === undefined) {
        throw new Error('intentCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (intentCreateObject !== null && intentCreateObject !== undefined) {
        let requestModelMapper = Mappers.ModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, intentCreateObject, 'intentCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(intentCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the intent models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListIntentsOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listIntentsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListIntentsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'IntentClassifierElementType',
                    type: {
                      name: 'Composite',
                      className: 'IntentClassifier'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds an entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelCreateObject} modelCreateObject A model object containing the
   * name for the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (modelCreateObject === null || modelCreateObject === undefined) {
        throw new Error('modelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (modelCreateObject !== null && modelCreateObject !== undefined) {
        let requestModelMapper = Mappers.ModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, modelCreateObject, 'modelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(modelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListEntitiesOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listEntitiesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListEntitiesOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a hierarchical entity extractor to the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {HierarchicalEntityModel} hierarchicalModelCreateObject A model
   * containing the name and children of the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addHierarchicalEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hierarchicalModelCreateObject === null || hierarchicalModelCreateObject === undefined) {
        throw new Error('hierarchicalModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (hierarchicalModelCreateObject !== null && hierarchicalModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.HierarchicalEntityModel;
        requestModel = client.serializer.serialize(requestModelMapper, hierarchicalModelCreateObject, 'hierarchicalModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(hierarchicalModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the hierarchical entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListHierarchicalEntitiesOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listHierarchicalEntitiesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListHierarchicalEntitiesOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'HierarchicalEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'HierarchicalEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a composite entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {CompositeEntityModel} compositeModelCreateObject A model containing
   * the name and children of the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addCompositeEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (compositeModelCreateObject === null || compositeModelCreateObject === undefined) {
        throw new Error('compositeModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (compositeModelCreateObject !== null && compositeModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.CompositeEntityModel;
        requestModel = client.serializer.serialize(requestModelMapper, compositeModelCreateObject, 'compositeModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(compositeModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the composite entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListCompositeEntitiesOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listCompositeEntitiesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListCompositeEntitiesOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'CompositeEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'CompositeEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the closedlist models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListClosedListsOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listClosedListsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListClosedListsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'ClosedListEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'ClosedListEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a closed list model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ClosedListModelCreateObject} closedListModelCreateObject A model
   * containing the name and words for the new closed list entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addClosedListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (closedListModelCreateObject === null || closedListModelCreateObject === undefined) {
        throw new Error('closedListModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (closedListModelCreateObject !== null && closedListModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.ClosedListModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, closedListModelCreateObject, 'closedListModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(closedListModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a list of prebuilt entity extractors to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string[]} prebuiltExtractorNames An array of prebuilt entity
   * extractor names.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addPrebuiltWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[], options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (!Array.isArray(prebuiltExtractorNames)) {
        throw new Error('prebuiltExtractorNames cannot be null or undefined and it must be of type array.');
      }
      for (let i = 0; i < prebuiltExtractorNames.length; i++) {
        if (prebuiltExtractorNames[i] !== null && prebuiltExtractorNames[i] !== undefined && typeof prebuiltExtractorNames[i].valueOf() !== 'string') {
          throw new Error('prebuiltExtractorNames[i] must be of type string.');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (prebuiltExtractorNames !== null && prebuiltExtractorNames !== undefined) {
        let requestModelMapper = {
          required: true,
          serializedName: 'prebuiltExtractorNames',
          type: {
            name: 'Sequence',
            element: {
                required: false,
                serializedName: 'stringElementType',
                type: {
                  name: 'String'
                }
            }
          }
        };
        requestModel = client.serializer.serialize(requestModelMapper, prebuiltExtractorNames, 'prebuiltExtractorNames');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(prebuiltExtractorNames, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'PrebuiltEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'PrebuiltEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the prebuilt entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListPrebuiltsOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listPrebuiltsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListPrebuiltsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'PrebuiltEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'PrebuiltEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets all the available prebuilt entity extractors for the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listPrebuiltEntitiesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/listprebuilts';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'AvailablePrebuiltEntityModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'AvailablePrebuiltEntityModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the application version models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListModelsOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listModelsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListModelsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/models';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'ModelInfoResponseElementType',
                    type: {
                      name: 'Composite',
                      className: 'ModelInfoResponse'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets the utterances for the given model in the given app version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} modelId The ID (GUID) of the model.
   *
   * @param {ModelExamplesMethodOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async examplesMethodWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string, options?: Models.ModelExamplesMethodOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (modelId === null || modelId === undefined || typeof modelId.valueOf() !== 'string') {
        throw new Error('modelId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/models/{modelId}/examples';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{modelId}', encodeURIComponent(modelId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'LabelTextObjectElementType',
                    type: {
                      name: 'Composite',
                      className: 'LabelTextObject'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the intent model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getIntentWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (intentId === null || intentId === undefined || typeof intentId.valueOf() !== 'string' || !msRest.isValidUuid(intentId)) {
        throw new Error('intentId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents/{intentId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{intentId}', encodeURIComponent(intentId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.IntentClassifier;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates the name of an intent classifier.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelUpdateObject} modelUpdateObject A model object containing the
   * new intent classifier name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateIntentWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (intentId === null || intentId === undefined || typeof intentId.valueOf() !== 'string' || !msRest.isValidUuid(intentId)) {
        throw new Error('intentId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (modelUpdateObject === null || modelUpdateObject === undefined) {
        throw new Error('modelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents/{intentId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{intentId}', encodeURIComponent(intentId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (modelUpdateObject !== null && modelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.ModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, modelUpdateObject, 'modelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(modelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes an intent classifier from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelDeleteIntentOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteIntentWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: Models.ModelDeleteIntentOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let deleteUtterances = (options && options.deleteUtterances !== undefined) ? options.deleteUtterances : false;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (intentId === null || intentId === undefined || typeof intentId.valueOf() !== 'string' || !msRest.isValidUuid(intentId)) {
        throw new Error('intentId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (deleteUtterances !== null && deleteUtterances !== undefined && typeof deleteUtterances !== 'boolean') {
        throw new Error('deleteUtterances must be of type boolean.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents/{intentId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{intentId}', encodeURIComponent(intentId.toString()));
    let queryParamsArray: Array<any> = [];
    if (deleteUtterances !== null && deleteUtterances !== undefined) {
      queryParamsArray.push('deleteUtterances=' + encodeURIComponent(deleteUtterances.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates the name of an entity extractor.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {ModelUpdateObject} modelUpdateObject A model object containing the
   * new entity extractor name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (modelUpdateObject === null || modelUpdateObject === undefined) {
        throw new Error('modelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (modelUpdateObject !== null && modelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.ModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, modelUpdateObject, 'modelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(modelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes an entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getHierarchicalEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.HierarchicalEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates the name and children of a hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {HierarchicalEntityModel} hierarchicalModelUpdateObject Model
   * containing names of the children of the hierarchical entity.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateHierarchicalEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hierarchicalModelUpdateObject === null || hierarchicalModelUpdateObject === undefined) {
        throw new Error('hierarchicalModelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (hierarchicalModelUpdateObject !== null && hierarchicalModelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.HierarchicalEntityModel;
        requestModel = client.serializer.serialize(requestModelMapper, hierarchicalModelUpdateObject, 'hierarchicalModelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(hierarchicalModelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a hierarchical entity extractor from the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteHierarchicalEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the composite entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getCompositeEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.CompositeEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates the composite entity extractor.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {CompositeEntityModel} compositeModelUpdateObject A model object
   * containing the new entity extractor name and children.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateCompositeEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (compositeModelUpdateObject === null || compositeModelUpdateObject === undefined) {
        throw new Error('compositeModelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (compositeModelUpdateObject !== null && compositeModelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.CompositeEntityModel;
        requestModel = client.serializer.serialize(requestModelMapper, compositeModelUpdateObject, 'compositeModelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(compositeModelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a composite entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteCompositeEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information of a closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getClosedListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.ClosedListEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates the closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {ClosedListModelUpdateObject} closedListModelUpdateObject The new
   * entity name and words list.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateClosedListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (closedListModelUpdateObject === null || closedListModelUpdateObject === undefined) {
        throw new Error('closedListModelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (closedListModelUpdateObject !== null && closedListModelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.ClosedListModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, closedListModelUpdateObject, 'closedListModelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(closedListModelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a batch of sublists to an existing closedlist.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {ClosedListModelPatchObject} closedListModelPatchObject A words list
   * batch.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async patchClosedListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (closedListModelPatchObject === null || closedListModelPatchObject === undefined) {
        throw new Error('closedListModelPatchObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PATCH';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (closedListModelPatchObject !== null && closedListModelPatchObject !== undefined) {
        let requestModelMapper = Mappers.ClosedListModelPatchObject;
        requestModel = client.serializer.serialize(requestModelMapper, closedListModelPatchObject, 'closedListModelPatchObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(closedListModelPatchObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a closed list model from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteClosedListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the prebuilt entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} prebuiltId The prebuilt entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPrebuiltWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (prebuiltId === null || prebuiltId === undefined || typeof prebuiltId.valueOf() !== 'string' || !msRest.isValidUuid(prebuiltId)) {
        throw new Error('prebuiltId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{prebuiltId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{prebuiltId}', encodeURIComponent(prebuiltId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.PrebuiltEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a prebuilt entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} prebuiltId The prebuilt entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deletePrebuiltWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (prebuiltId === null || prebuiltId === undefined || typeof prebuiltId.valueOf() !== 'string' || !msRest.isValidUuid(prebuiltId)) {
        throw new Error('prebuiltId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{prebuiltId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{prebuiltId}', encodeURIComponent(prebuiltId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a sublist of a specific closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {number} subListId The sublist ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteSubListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (subListId === null || subListId === undefined || typeof subListId !== 'number') {
        throw new Error('subListId cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists/{subListId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));
    requestUrl = requestUrl.replace('{subListId}', encodeURIComponent(subListId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Updates one of the closed list's sublists.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {number} subListId The sublist ID.
   *
   * @param {WordListBaseUpdateObject} wordListBaseUpdateObject A sublist update
   * object containing the new canonical form and the list of words.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateSubListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (subListId === null || subListId === undefined || typeof subListId !== 'number') {
        throw new Error('subListId cannot be null or undefined and it must be of type number.');
      }
      if (wordListBaseUpdateObject === null || wordListBaseUpdateObject === undefined) {
        throw new Error('wordListBaseUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists/{subListId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));
    requestUrl = requestUrl.replace('{subListId}', encodeURIComponent(subListId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (wordListBaseUpdateObject !== null && wordListBaseUpdateObject !== undefined) {
        let requestModelMapper = Mappers.WordListBaseUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, wordListBaseUpdateObject, 'wordListBaseUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(wordListBaseUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Suggests examples that would improve the accuracy of the intent model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelGetIntentSuggestionsOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getIntentSuggestionsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: Models.ModelGetIntentSuggestionsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (intentId === null || intentId === undefined || typeof intentId.valueOf() !== 'string' || !msRest.isValidUuid(intentId)) {
        throw new Error('intentId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/intents/{intentId}/suggest';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{intentId}', encodeURIComponent(intentId.toString()));
    let queryParamsArray: Array<any> = [];
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'IntentsSuggestionExampleElementType',
                    type: {
                      name: 'Composite',
                      className: 'IntentsSuggestionExample'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Get suggestion examples that would improve the accuracy of the entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The target entity extractor model to enhance.
   *
   * @param {ModelGetEntitySuggestionsOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntitySuggestionsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: Models.ModelGetEntitySuggestionsOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/suggest';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    let queryParamsArray: Array<any> = [];
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntitiesSuggestionExampleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntitiesSuggestionExample'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a list to an existing closed list.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {WordListObject} wordListCreateObject Words list.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addSubListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (clEntityId === null || clEntityId === undefined || typeof clEntityId.valueOf() !== 'string' || !msRest.isValidUuid(clEntityId)) {
        throw new Error('clEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (wordListCreateObject === null || wordListCreateObject === undefined) {
        throw new Error('wordListCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{clEntityId}/sublists';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{clEntityId}', encodeURIComponent(clEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (wordListCreateObject !== null && wordListCreateObject !== undefined) {
        let requestModelMapper = Mappers.WordListObject;
        requestModel = client.serializer.serialize(requestModelMapper, wordListCreateObject, 'wordListCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(wordListCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Number'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a customizable prebuilt domain along with all of its models to this
   * application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainCreateBaseObject} prebuiltDomainObject A prebuilt
   * domain create object containing the name of the domain.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addCustomPrebuiltDomainWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (prebuiltDomainObject === null || prebuiltDomainObject === undefined) {
        throw new Error('prebuiltDomainObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltdomains';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (prebuiltDomainObject !== null && prebuiltDomainObject !== undefined) {
        let requestModelMapper = Mappers.PrebuiltDomainCreateBaseObject;
        requestModel = client.serializer.serialize(requestModelMapper, prebuiltDomainObject, 'prebuiltDomainObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(prebuiltDomainObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'stringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a custom prebuilt intent model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainModelCreateObject} prebuiltDomainModelCreateObject A
   * model object containing the name of the custom prebuilt intent and the name
   * of the domain to which this model belongs.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addCustomPrebuiltIntentWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (prebuiltDomainModelCreateObject === null || prebuiltDomainModelCreateObject === undefined) {
        throw new Error('prebuiltDomainModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltintents';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (prebuiltDomainModelCreateObject !== null && prebuiltDomainModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.PrebuiltDomainModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, prebuiltDomainModelCreateObject, 'prebuiltDomainModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(prebuiltDomainModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets custom prebuilt intents information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listCustomPrebuiltIntentsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltintents';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'IntentClassifierElementType',
                    type: {
                      name: 'Composite',
                      className: 'IntentClassifier'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds a custom prebuilt entity model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainModelCreateObject} prebuiltDomainModelCreateObject A
   * model object containing the name of the custom prebuilt entity and the name
   * of the domain to which this model belongs.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addCustomPrebuiltEntityWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (prebuiltDomainModelCreateObject === null || prebuiltDomainModelCreateObject === undefined) {
        throw new Error('prebuiltDomainModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (prebuiltDomainModelCreateObject !== null && prebuiltDomainModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.PrebuiltDomainModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, prebuiltDomainModelCreateObject, 'prebuiltDomainModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(prebuiltDomainModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets all custom prebuilt entities information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listCustomPrebuiltEntitiesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets all custom prebuilt models information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async listCustomPrebuiltModelsWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltmodels';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'CustomPrebuiltModelElementType',
                    type: {
                      name: 'Composite',
                      className: 'CustomPrebuiltModel'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a prebuilt domain's models from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} domainName Domain name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteCustomPrebuiltDomainWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (domainName === null || domainName === undefined || typeof domainName.valueOf() !== 'string') {
        throw new Error('domainName cannot be null or undefined and it must be of type string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltdomains/{domainName}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{domainName}', encodeURIComponent(domainName));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Gets information about the hierarchical entity child model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getHierarchicalEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hChildId === null || hChildId === undefined || typeof hChildId.valueOf() !== 'string' || !msRest.isValidUuid(hChildId)) {
        throw new Error('hChildId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{hChildId}', encodeURIComponent(hChildId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.HierarchicalChildEntity;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Renames a single child in an existing hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {HierarchicalChildModelUpdateObject}
   * hierarchicalChildModelUpdateObject Model object containing new name of the
   * hierarchical entity child.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateHierarchicalEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hChildId === null || hChildId === undefined || typeof hChildId.valueOf() !== 'string' || !msRest.isValidUuid(hChildId)) {
        throw new Error('hChildId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hierarchicalChildModelUpdateObject === null || hierarchicalChildModelUpdateObject === undefined) {
        throw new Error('hierarchicalChildModelUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{hChildId}', encodeURIComponent(hChildId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (hierarchicalChildModelUpdateObject !== null && hierarchicalChildModelUpdateObject !== undefined) {
        let requestModelMapper = Mappers.HierarchicalChildModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, hierarchicalChildModelUpdateObject, 'hierarchicalChildModelUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(hierarchicalChildModelUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a hierarchical entity extractor child from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteHierarchicalEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hChildId === null || hChildId === undefined || typeof hChildId.valueOf() !== 'string' || !msRest.isValidUuid(hChildId)) {
        throw new Error('hChildId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children/{hChildId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{hChildId}', encodeURIComponent(hChildId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Creates a single child in an existing hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {HierarchicalChildModelCreateObject}
   * hierarchicalChildModelCreateObject A model object containing the name of the
   * new hierarchical child model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addHierarchicalEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (hierarchicalChildModelCreateObject === null || hierarchicalChildModelCreateObject === undefined) {
        throw new Error('hierarchicalChildModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/children';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (hierarchicalChildModelCreateObject !== null && hierarchicalChildModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.HierarchicalChildModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, hierarchicalChildModelCreateObject, 'hierarchicalChildModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(hierarchicalChildModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Creates a single child in an existing composite entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {CompositeChildModelCreateObject} compositeChildModelCreateObject A
   * model object containing the name of the new composite child model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addCompositeEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (compositeChildModelCreateObject === null || compositeChildModelCreateObject === undefined) {
        throw new Error('compositeChildModelCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/children';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (compositeChildModelCreateObject !== null && compositeChildModelCreateObject !== undefined) {
        let requestModelMapper = Mappers.CompositeChildModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, compositeChildModelCreateObject, 'compositeChildModelCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(compositeChildModelCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Deletes a composite entity extractor child from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} cChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteCompositeEntityChildWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (cChildId === null || cChildId === undefined || typeof cChildId.valueOf() !== 'string' || !msRest.isValidUuid(cChildId)) {
        throw new Error('cChildId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/children/{cChildId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));
    requestUrl = requestUrl.replace('{cChildId}', encodeURIComponent(cChildId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Gets information about the regex entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelGetRegexEntityInfosOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getRegexEntityInfosWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelGetRegexEntityInfosOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'RegexEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'RegexEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Adds a regex entity model to the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RegexModelCreateObject} regexEntityExtractorCreateObj A model object
   * containing the name and regex pattern for the new regex entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createRegexEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (regexEntityExtractorCreateObj === null || regexEntityExtractorCreateObj === undefined) {
        throw new Error('regexEntityExtractorCreateObj cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (regexEntityExtractorCreateObj !== null && regexEntityExtractorCreateObj !== undefined) {
        let requestModelMapper = Mappers.RegexModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, regexEntityExtractorCreateObj, 'regexEntityExtractorCreateObj');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(regexEntityExtractorCreateObj, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get information about the Pattern.Any entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelGetPatternAnyEntityInfosOptionalParams} [options] Optional
   * Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPatternAnyEntityInfosWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelGetPatternAnyEntityInfosOptionalParams): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    let skip = (options && options.skip !== undefined) ? options.skip : 0;
    let take = (options && options.take !== undefined) ? options.take : 100;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (skip !== null && skip !== undefined && typeof skip !== 'number') {
        throw new Error('skip must be of type number.');
      }
      if (skip !== null && skip !== undefined) {
        if (skip < 0)
        {
          throw new Error('"skip" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
      if (take !== null && take !== undefined && typeof take !== 'number') {
        throw new Error('take must be of type number.');
      }
      if (take !== null && take !== undefined) {
        if (take > 500)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMaximum": 500');
        }
        if (take < 0)
        {
          throw new Error('"take" should satisfy the constraint - "InclusiveMinimum": 0');
        }
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    let queryParamsArray: Array<any> = [];
    if (skip !== null && skip !== undefined) {
      queryParamsArray.push('skip=' + encodeURIComponent(skip.toString()));
    }
    if (take !== null && take !== undefined) {
      queryParamsArray.push('take=' + encodeURIComponent(take.toString()));
    }
    if (queryParamsArray.length > 0) {
      requestUrl += '?' + queryParamsArray.join('&');
    }

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'PatternAnyEntityExtractorElementType',
                    type: {
                      name: 'Composite',
                      className: 'PatternAnyEntityExtractor'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Adds a pattern.any entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PatternAnyModelCreateObject} extractorCreateObject A model object
   * containing the name and explicit list for the new Pattern.Any entity
   * extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createPatternAnyEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (extractorCreateObject === null || extractorCreateObject === undefined) {
        throw new Error('extractorCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (extractorCreateObject !== null && extractorCreateObject !== undefined) {
        let requestModelMapper = Mappers.PatternAnyModelCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, extractorCreateObject, 'extractorCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(extractorCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPrebuiltEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createPrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getClosedListEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createClosedListEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getRegexEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createRegexEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getCompositeEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createCompositeEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPatternAnyEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createPatternAnyEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getHierarchicalEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createHierarchicalEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getCustomPrebuiltEntityRolesWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'EntityRoleElementType',
                    type: {
                      name: 'Composite',
                      className: 'EntityRole'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async createCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleCreateObject === null || entityRoleCreateObject === undefined) {
        throw new Error('entityRoleCreateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleCreateObject !== null && entityRoleCreateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleCreateObject, 'entityRoleCreateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleCreateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'String'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get the explicit list of the pattern.any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getExplicitListWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serializedName: 'ExplicitListItemElementType',
                    type: {
                      name: 'Composite',
                      className: 'ExplicitListItem'
                    }
                }
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Add a new item to the explicit list for the Pattern.Any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {ExplicitListItemCreateObject} item The new explicit list item.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async addExplicitListItemWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (item === null || item === undefined) {
        throw new Error('item cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'POST';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (item !== null && item !== undefined) {
        let requestModelMapper = Mappers.ExplicitListItemCreateObject;
        requestModel = client.serializer.serialize(requestModelMapper, item, 'item');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(item, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 201) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 201) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = {
              required: false,
              serializedName: 'parsedResponse',
              type: {
                name: 'Number'
              }
            };
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Gets information of a regex entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getRegexEntityEntityInfoWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (regexEntityId === null || regexEntityId === undefined || typeof regexEntityId.valueOf() !== 'string' || !msRest.isValidUuid(regexEntityId)) {
        throw new Error('regexEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{regexEntityId}', encodeURIComponent(regexEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.RegexEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Updates the regex entity model .
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity extractor ID.
   *
   * @param {RegexModelUpdateObject} regexEntityUpdateObject An object containing
   * the new entity name and regex pattern.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateRegexEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (regexEntityId === null || regexEntityId === undefined || typeof regexEntityId.valueOf() !== 'string' || !msRest.isValidUuid(regexEntityId)) {
        throw new Error('regexEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (regexEntityUpdateObject === null || regexEntityUpdateObject === undefined) {
        throw new Error('regexEntityUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{regexEntityId}', encodeURIComponent(regexEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (regexEntityUpdateObject !== null && regexEntityUpdateObject !== undefined) {
        let requestModelMapper = Mappers.RegexModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, regexEntityUpdateObject, 'regexEntityUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(regexEntityUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Deletes a regex entity model from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteRegexEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (regexEntityId === null || regexEntityId === undefined || typeof regexEntityId.valueOf() !== 'string' || !msRest.isValidUuid(regexEntityId)) {
        throw new Error('regexEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{regexEntityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{regexEntityId}', encodeURIComponent(regexEntityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Gets information about the application version's Pattern.Any model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPatternAnyEntityInfoWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.PatternAnyEntityExtractor;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Updates the name and explicit list of a Pattern.Any entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {PatternAnyModelUpdateObject} patternAnyUpdateObject An object
   * containing the explicit list of the Pattern.Any entity.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updatePatternAnyEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (patternAnyUpdateObject === null || patternAnyUpdateObject === undefined) {
        throw new Error('patternAnyUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (patternAnyUpdateObject !== null && patternAnyUpdateObject !== undefined) {
        let requestModelMapper = Mappers.PatternAnyModelUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, patternAnyUpdateObject, 'patternAnyUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(patternAnyUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Deletes a Pattern.Any entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deletePatternAnyEntityModelWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/entities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updatePrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deletePrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/prebuilts/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getClosedListEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateClosedListEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteClosedListEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/closedlists/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getRegexEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateRegexEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteRegexEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/regexentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getCompositeEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateCompositeEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteCompositeEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (cEntityId === null || cEntityId === undefined || typeof cEntityId.valueOf() !== 'string' || !msRest.isValidUuid(cEntityId)) {
        throw new Error('cEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/compositeentities/{cEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{cEntityId}', encodeURIComponent(cEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getPatternAnyEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updatePatternAnyEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deletePatternAnyEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getHierarchicalEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateHierarchicalEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteHierarchicalEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (hEntityId === null || hEntityId === undefined || typeof hEntityId.valueOf() !== 'string' || !msRest.isValidUuid(hEntityId)) {
        throw new Error('hEntityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/hierarchicalentities/{hEntityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{hEntityId}', encodeURIComponent(hEntityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getCustomEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.EntityRole;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (entityRoleUpdateObject === null || entityRoleUpdateObject === undefined) {
        throw new Error('entityRoleUpdateObject cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (entityRoleUpdateObject !== null && entityRoleUpdateObject !== undefined) {
        let requestModelMapper = Mappers.EntityRoleUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, entityRoleUpdateObject, 'entityRoleUpdateObject');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(entityRoleUpdateObject, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteCustomEntityRoleWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (roleId === null || roleId === undefined || typeof roleId.valueOf() !== 'string' || !msRest.isValidUuid(roleId)) {
        throw new Error('roleId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/customprebuiltentities/{entityId}/roles/{roleId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{roleId}', encodeURIComponent(roleId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Get the explicit list of the pattern.any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity Id.
   *
   * @param {number} itemId The explicit list item Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async getExplicitListItemWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (itemId === null || itemId === undefined || typeof itemId !== 'number') {
        throw new Error('itemId cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{itemId}', encodeURIComponent(itemId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'GET';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.ExplicitListItem;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Updates an explicit list item for a Pattern.Any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {number} itemId The explicit list item ID.
   *
   * @param {ExplicitListItemUpdateObject} item The new explicit list item.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async updateExplicitListItemWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (itemId === null || itemId === undefined || typeof itemId !== 'number') {
        throw new Error('itemId cannot be null or undefined and it must be of type number.');
      }
      if (item === null || item === undefined) {
        throw new Error('item cannot be null or undefined.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{itemId}', encodeURIComponent(itemId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'PUT';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Serialize Request
    let requestContent = null;
    let requestModel = null;
    try {
      if (item !== null && item !== undefined) {
        let requestModelMapper = Mappers.ExplicitListItemUpdateObject;
        requestModel = client.serializer.serialize(requestModelMapper, item, 'item');
        requestContent = JSON.stringify(requestModel);
      }
    } catch (error) {
      let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
          `payload - ${JSON.stringify(item, null, 2)}.`);
      return Promise.reject(serializationError);
    }
    httpRequest.body = requestContent;
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * @summary Delete the explicit list item from the Pattern.any explicit list.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The pattern.any entity id.
   *
   * @param {number} itemId The explicit list item which will be deleted.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  async deleteExplicitListItemWithHttpOperationResponse(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse> {
    let client = this.client;
    // Validate
    try {
      if (azureRegion) {
        let allowedValues = [ 'westus', 'westeurope', 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus', 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth' ];
        if (!allowedValues.some( function(item) { return item === azureRegion; })) {
          throw new Error(azureRegion + ' is not a valid value. The valid values are: ' + allowedValues);
        }
      } else {
        throw new Error('azureRegion cannot be null or undefined.');
      }
      if (appId === null || appId === undefined || typeof appId.valueOf() !== 'string' || !msRest.isValidUuid(appId)) {
        throw new Error('appId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (versionId === null || versionId === undefined || typeof versionId.valueOf() !== 'string') {
        throw new Error('versionId cannot be null or undefined and it must be of type string.');
      }
      if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string' || !msRest.isValidUuid(entityId)) {
        throw new Error('entityId cannot be null or undefined and it must be of type string and must be a valid string.');
      }
      if (itemId === null || itemId === undefined || typeof itemId !== 'number') {
        throw new Error('itemId cannot be null or undefined and it must be of type number.');
      }
    } catch (error) {
      return Promise.reject(error);
    }

    // Construct URL
    let baseUrl = this.client.baseUri;
    let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'apps/{appId}/versions/{versionId}/patternanyentities/{entityId}/explicitlist/{itemId}';
    requestUrl = requestUrl.replace('{AzureRegion}', azureRegion);
    requestUrl = requestUrl.replace('{appId}', encodeURIComponent(appId.toString()));
    requestUrl = requestUrl.replace('{versionId}', encodeURIComponent(versionId));
    requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId.toString()));
    requestUrl = requestUrl.replace('{itemId}', encodeURIComponent(itemId.toString()));

    // Create HTTP transport objects
    let httpRequest = new WebResource();
    httpRequest.method = 'DELETE';
    httpRequest.url = requestUrl;
    httpRequest.headers = {};
    // Set Headers
    httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
    if(options && options.customHeaders) {
      for(let headerName in options.customHeaders) {
        if (options.customHeaders.hasOwnProperty(headerName)) {
          httpRequest.headers[headerName] = options.customHeaders[headerName];
        }
      }
    }
    // Send Request
    let operationRes: msRest.HttpOperationResponse;
    try {
      operationRes = await client.sendRequest(httpRequest);
      let response = operationRes.response;
      let statusCode = response.status;
      if (statusCode !== 200) {
        let error = new msRest.RestError(operationRes.bodyAsText as string);
        error.statusCode = response.status;
        error.request = msRest.stripRequest(httpRequest);
        error.response = msRest.stripResponse(response);
        let parsedErrorResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedErrorResponse) {
            let internalError = null;
            if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
            error.code = internalError ? internalError.code : parsedErrorResponse.code;
            error.message = internalError ? internalError.message : parsedErrorResponse.message;
          }
          if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
            let resultMapper = Mappers.ErrorResponse;
            error.body = client.serializer.deserialize(resultMapper, parsedErrorResponse, 'error.body');
          }
        } catch (defaultError) {
          error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                           `- "${operationRes.bodyAsText}" for the default response.`;
          return Promise.reject(error);
        }
        return Promise.reject(error);
      }
      // Deserialize Response
      if (statusCode === 200) {
        let parsedResponse = operationRes.bodyAsJson as { [key: string]: any };
        try {
          if (parsedResponse !== null && parsedResponse !== undefined) {
            let resultMapper = Mappers.OperationStatus;
            operationRes.bodyAsJson = client.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.bodyAsJson');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(response);
          return Promise.reject(deserializationError);
        }
      }

    } catch(err) {
      return Promise.reject(err);
    }

    return Promise.resolve(operationRes);
  }

  /**
   * Adds an intent classifier to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelCreateObject} intentCreateObject A model object containing the
   * name of the new intent classifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject): Promise<string>;
  addIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentCreateObject: Models.ModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the intent models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListIntentsOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.IntentClassifier[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.IntentClassifier[]>;
  listIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListIntentsOptionalParams): Promise<Models.IntentClassifier[]>;
  listIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.IntentClassifier[]>): void;
  listIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListIntentsOptionalParams, callback: msRest.ServiceCallback<Models.IntentClassifier[]>): void;
  listIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListIntentsOptionalParams, callback?: msRest.ServiceCallback<Models.IntentClassifier[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.IntentClassifier[]>;
    if (!callback) {
      return this.listIntentsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.IntentClassifier[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listIntentsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.IntentClassifier[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds an entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelCreateObject} modelCreateObject A model object containing the
   * name for the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject): Promise<string>;
  addEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelCreateObject: Models.ModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addEntityWithHttpOperationResponse(azureRegion, appId, versionId, modelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addEntityWithHttpOperationResponse(azureRegion, appId, versionId, modelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListEntitiesOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.EntityExtractor[]>;
  listEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListEntitiesOptionalParams): Promise<Models.EntityExtractor[]>;
  listEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.EntityExtractor[]>): void;
  listEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListEntitiesOptionalParams, callback: msRest.ServiceCallback<Models.EntityExtractor[]>): void;
  listEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListEntitiesOptionalParams, callback?: msRest.ServiceCallback<Models.EntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityExtractor[]>;
    if (!callback) {
      return this.listEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a hierarchical entity extractor to the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {HierarchicalEntityModel} hierarchicalModelCreateObject A model
   * containing the name and children of the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel): Promise<string>;
  addHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel, options: msRest.RequestOptionsBase): Promise<string>;
  addHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel, callback: msRest.ServiceCallback<string>): void;
  addHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hierarchicalModelCreateObject: Models.HierarchicalEntityModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hierarchicalModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hierarchicalModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the hierarchical entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListHierarchicalEntitiesOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.HierarchicalEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listHierarchicalEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.HierarchicalEntityExtractor[]>;
  listHierarchicalEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListHierarchicalEntitiesOptionalParams): Promise<Models.HierarchicalEntityExtractor[]>;
  listHierarchicalEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.HierarchicalEntityExtractor[]>): void;
  listHierarchicalEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListHierarchicalEntitiesOptionalParams, callback: msRest.ServiceCallback<Models.HierarchicalEntityExtractor[]>): void;
  listHierarchicalEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListHierarchicalEntitiesOptionalParams, callback?: msRest.ServiceCallback<Models.HierarchicalEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.HierarchicalEntityExtractor[]>;
    if (!callback) {
      return this.listHierarchicalEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.HierarchicalEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listHierarchicalEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.HierarchicalEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a composite entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {CompositeEntityModel} compositeModelCreateObject A model containing
   * the name and children of the new entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel): Promise<string>;
  addCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel, options: msRest.RequestOptionsBase): Promise<string>;
  addCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel, callback: msRest.ServiceCallback<string>): void;
  addCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, compositeModelCreateObject: Models.CompositeEntityModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, compositeModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, compositeModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the composite entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListCompositeEntitiesOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.CompositeEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listCompositeEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.CompositeEntityExtractor[]>;
  listCompositeEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListCompositeEntitiesOptionalParams): Promise<Models.CompositeEntityExtractor[]>;
  listCompositeEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.CompositeEntityExtractor[]>): void;
  listCompositeEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListCompositeEntitiesOptionalParams, callback: msRest.ServiceCallback<Models.CompositeEntityExtractor[]>): void;
  listCompositeEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListCompositeEntitiesOptionalParams, callback?: msRest.ServiceCallback<Models.CompositeEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CompositeEntityExtractor[]>;
    if (!callback) {
      return this.listCompositeEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.CompositeEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listCompositeEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.CompositeEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the closedlist models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListClosedListsOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ClosedListEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listClosedLists(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.ClosedListEntityExtractor[]>;
  listClosedLists(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListClosedListsOptionalParams): Promise<Models.ClosedListEntityExtractor[]>;
  listClosedLists(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.ClosedListEntityExtractor[]>): void;
  listClosedLists(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListClosedListsOptionalParams, callback: msRest.ServiceCallback<Models.ClosedListEntityExtractor[]>): void;
  listClosedLists(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListClosedListsOptionalParams, callback?: msRest.ServiceCallback<Models.ClosedListEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ClosedListEntityExtractor[]>;
    if (!callback) {
      return this.listClosedListsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ClosedListEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listClosedListsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ClosedListEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a closed list model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ClosedListModelCreateObject} closedListModelCreateObject A model
   * containing the name and words for the new closed list entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject): Promise<string>;
  addClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, closedListModelCreateObject: Models.ClosedListModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addClosedListWithHttpOperationResponse(azureRegion, appId, versionId, closedListModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addClosedListWithHttpOperationResponse(azureRegion, appId, versionId, closedListModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a list of prebuilt entity extractors to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string[]} prebuiltExtractorNames An array of prebuilt entity
   * extractor names.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.PrebuiltEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[]): Promise<Models.PrebuiltEntityExtractor[]>;
  addPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[], options: msRest.RequestOptionsBase): Promise<Models.PrebuiltEntityExtractor[]>;
  addPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[], callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): void;
  addPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[], options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): void;
  addPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltExtractorNames: string[], options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>;
    if (!callback) {
      return this.addPrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltExtractorNames, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.PrebuiltEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addPrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltExtractorNames, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.PrebuiltEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the prebuilt entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListPrebuiltsOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.PrebuiltEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listPrebuilts(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.PrebuiltEntityExtractor[]>;
  listPrebuilts(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListPrebuiltsOptionalParams): Promise<Models.PrebuiltEntityExtractor[]>;
  listPrebuilts(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): void;
  listPrebuilts(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListPrebuiltsOptionalParams, callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): void;
  listPrebuilts(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListPrebuiltsOptionalParams, callback?: msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PrebuiltEntityExtractor[]>;
    if (!callback) {
      return this.listPrebuiltsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.PrebuiltEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listPrebuiltsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.PrebuiltEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets all the available prebuilt entity extractors for the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.AvailablePrebuiltEntityModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.AvailablePrebuiltEntityModel[]>;
  listPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase): Promise<Models.AvailablePrebuiltEntityModel[]>;
  listPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.AvailablePrebuiltEntityModel[]>): void;
  listPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.AvailablePrebuiltEntityModel[]>): void;
  listPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.AvailablePrebuiltEntityModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.AvailablePrebuiltEntityModel[]>;
    if (!callback) {
      return this.listPrebuiltEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.AvailablePrebuiltEntityModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listPrebuiltEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.AvailablePrebuiltEntityModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the application version models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelListModelsOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ModelInfoResponse[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listModels(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.ModelInfoResponse[]>;
  listModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListModelsOptionalParams): Promise<Models.ModelInfoResponse[]>;
  listModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.ModelInfoResponse[]>): void;
  listModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelListModelsOptionalParams, callback: msRest.ServiceCallback<Models.ModelInfoResponse[]>): void;
  listModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelListModelsOptionalParams, callback?: msRest.ServiceCallback<Models.ModelInfoResponse[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ModelInfoResponse[]>;
    if (!callback) {
      return this.listModelsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ModelInfoResponse[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listModelsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ModelInfoResponse[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets the utterances for the given model in the given app version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} modelId The ID (GUID) of the model.
   *
   * @param {ModelExamplesMethodOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.LabelTextObject[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  examplesMethod(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string): Promise<Models.LabelTextObject[]>;
  examplesMethod(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string, options: Models.ModelExamplesMethodOptionalParams): Promise<Models.LabelTextObject[]>;
  examplesMethod(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string, callback: msRest.ServiceCallback<Models.LabelTextObject[]>): void;
  examplesMethod(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string, options: Models.ModelExamplesMethodOptionalParams, callback: msRest.ServiceCallback<Models.LabelTextObject[]>): void;
  examplesMethod(azureRegion: Models.AzureRegions, appId: string, versionId: string, modelId: string, options?: Models.ModelExamplesMethodOptionalParams, callback?: msRest.ServiceCallback<Models.LabelTextObject[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.LabelTextObject[]>;
    if (!callback) {
      return this.examplesMethodWithHttpOperationResponse(azureRegion, appId, versionId, modelId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.LabelTextObject[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.examplesMethodWithHttpOperationResponse(azureRegion, appId, versionId, modelId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.LabelTextObject[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the intent model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.IntentClassifier} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.IntentClassifier} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string): Promise<Models.IntentClassifier>;
  getIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: msRest.RequestOptionsBase): Promise<Models.IntentClassifier>;
  getIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, callback: msRest.ServiceCallback<Models.IntentClassifier>): void;
  getIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.IntentClassifier>): void;
  getIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.IntentClassifier>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.IntentClassifier>;
    if (!callback) {
      return this.getIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.IntentClassifier);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.IntentClassifier;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates the name of an intent classifier.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelUpdateObject} modelUpdateObject A model object containing the
   * new intent classifier name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject): Promise<Models.OperationStatus>;
  updateIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, modelUpdateObject: Models.ModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, modelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, modelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes an intent classifier from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelDeleteIntentOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string): Promise<Models.OperationStatus>;
  deleteIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: Models.ModelDeleteIntentOptionalParams): Promise<Models.OperationStatus>;
  deleteIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: Models.ModelDeleteIntentOptionalParams, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: Models.ModelDeleteIntentOptionalParams, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteIntentWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityExtractor>;
  getEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityExtractor>;
  getEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityExtractor>): void;
  getEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityExtractor>): void;
  getEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityExtractor>;
    if (!callback) {
      return this.getEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates the name of an entity extractor.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {ModelUpdateObject} modelUpdateObject A model object containing the
   * new entity extractor name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject): Promise<Models.OperationStatus>;
  updateEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, modelUpdateObject: Models.ModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, modelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, modelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes an entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.OperationStatus>;
  deleteEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteEntityWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.HierarchicalEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.HierarchicalEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string): Promise<Models.HierarchicalEntityExtractor>;
  getHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.HierarchicalEntityExtractor>;
  getHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, callback: msRest.ServiceCallback<Models.HierarchicalEntityExtractor>): void;
  getHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.HierarchicalEntityExtractor>): void;
  getHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.HierarchicalEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.HierarchicalEntityExtractor>;
    if (!callback) {
      return this.getHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.HierarchicalEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.HierarchicalEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates the name and children of a hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {HierarchicalEntityModel} hierarchicalModelUpdateObject Model
   * containing names of the children of the hierarchical entity.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel): Promise<Models.OperationStatus>;
  updateHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalModelUpdateObject: Models.HierarchicalEntityModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hierarchicalModelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hierarchicalModelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a hierarchical entity extractor from the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string): Promise<Models.OperationStatus>;
  deleteHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteHierarchicalEntityWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the composite entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.CompositeEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.CompositeEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string): Promise<Models.CompositeEntityExtractor>;
  getCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.CompositeEntityExtractor>;
  getCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, callback: msRest.ServiceCallback<Models.CompositeEntityExtractor>): void;
  getCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CompositeEntityExtractor>): void;
  getCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CompositeEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CompositeEntityExtractor>;
    if (!callback) {
      return this.getCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.CompositeEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.CompositeEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates the composite entity extractor.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {CompositeEntityModel} compositeModelUpdateObject A model object
   * containing the new entity extractor name and children.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel): Promise<Models.OperationStatus>;
  updateCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeModelUpdateObject: Models.CompositeEntityModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, compositeModelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, compositeModelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a composite entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string): Promise<Models.OperationStatus>;
  deleteCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteCompositeEntityWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information of a closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ClosedListEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.ClosedListEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string): Promise<Models.ClosedListEntityExtractor>;
  getClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.ClosedListEntityExtractor>;
  getClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, callback: msRest.ServiceCallback<Models.ClosedListEntityExtractor>): void;
  getClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ClosedListEntityExtractor>): void;
  getClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ClosedListEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ClosedListEntityExtractor>;
    if (!callback) {
      return this.getClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ClosedListEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ClosedListEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates the closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {ClosedListModelUpdateObject} closedListModelUpdateObject The new
   * entity name and words list.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject): Promise<Models.OperationStatus>;
  updateClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelUpdateObject: Models.ClosedListModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, closedListModelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, closedListModelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a batch of sublists to an existing closedlist.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {ClosedListModelPatchObject} closedListModelPatchObject A words list
   * batch.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  patchClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject): Promise<Models.OperationStatus>;
  patchClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  patchClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  patchClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  patchClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, closedListModelPatchObject: Models.ClosedListModelPatchObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.patchClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, closedListModelPatchObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.patchClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, closedListModelPatchObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a closed list model from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string): Promise<Models.OperationStatus>;
  deleteClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteClosedList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteClosedListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the prebuilt entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} prebuiltId The prebuilt entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.PrebuiltEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.PrebuiltEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string): Promise<Models.PrebuiltEntityExtractor>;
  getPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options: msRest.RequestOptionsBase): Promise<Models.PrebuiltEntityExtractor>;
  getPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor>): void;
  getPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.PrebuiltEntityExtractor>): void;
  getPrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.PrebuiltEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PrebuiltEntityExtractor>;
    if (!callback) {
      return this.getPrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.PrebuiltEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.PrebuiltEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a prebuilt entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} prebuiltId The prebuilt entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string): Promise<Models.OperationStatus>;
  deletePrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deletePrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePrebuilt(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deletePrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deletePrebuiltWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a sublist of a specific closed list model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {number} subListId The sublist ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number): Promise<Models.OperationStatus>;
  deleteSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, subListId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, subListId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Updates one of the closed list's sublists.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {number} subListId The sublist ID.
   *
   * @param {WordListBaseUpdateObject} wordListBaseUpdateObject A sublist update
   * object containing the new canonical form and the list of words.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject): Promise<Models.OperationStatus>;
  updateSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, subListId: number, wordListBaseUpdateObject: Models.WordListBaseUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, subListId, wordListBaseUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, subListId, wordListBaseUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Suggests examples that would improve the accuracy of the intent model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} intentId The intent classifier ID.
   *
   * @param {ModelGetIntentSuggestionsOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.IntentsSuggestionExample[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getIntentSuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string): Promise<Models.IntentsSuggestionExample[]>;
  getIntentSuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: Models.ModelGetIntentSuggestionsOptionalParams): Promise<Models.IntentsSuggestionExample[]>;
  getIntentSuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, callback: msRest.ServiceCallback<Models.IntentsSuggestionExample[]>): void;
  getIntentSuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options: Models.ModelGetIntentSuggestionsOptionalParams, callback: msRest.ServiceCallback<Models.IntentsSuggestionExample[]>): void;
  getIntentSuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, intentId: string, options?: Models.ModelGetIntentSuggestionsOptionalParams, callback?: msRest.ServiceCallback<Models.IntentsSuggestionExample[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.IntentsSuggestionExample[]>;
    if (!callback) {
      return this.getIntentSuggestionsWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.IntentsSuggestionExample[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getIntentSuggestionsWithHttpOperationResponse(azureRegion, appId, versionId, intentId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.IntentsSuggestionExample[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Get suggestion examples that would improve the accuracy of the entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The target entity extractor model to enhance.
   *
   * @param {ModelGetEntitySuggestionsOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntitiesSuggestionExample[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitySuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntitiesSuggestionExample[]>;
  getEntitySuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: Models.ModelGetEntitySuggestionsOptionalParams): Promise<Models.EntitiesSuggestionExample[]>;
  getEntitySuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntitiesSuggestionExample[]>): void;
  getEntitySuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: Models.ModelGetEntitySuggestionsOptionalParams, callback: msRest.ServiceCallback<Models.EntitiesSuggestionExample[]>): void;
  getEntitySuggestions(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: Models.ModelGetEntitySuggestionsOptionalParams, callback?: msRest.ServiceCallback<Models.EntitiesSuggestionExample[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntitiesSuggestionExample[]>;
    if (!callback) {
      return this.getEntitySuggestionsWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntitiesSuggestionExample[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntitySuggestionsWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntitiesSuggestionExample[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a list to an existing closed list.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} clEntityId The closed list entity extractor ID.
   *
   * @param {WordListObject} wordListCreateObject Words list.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {number} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject): Promise<number>;
  addSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject, options: msRest.RequestOptionsBase): Promise<number>;
  addSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject, callback: msRest.ServiceCallback<number>): void;
  addSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<number>): void;
  addSubList(azureRegion: Models.AzureRegions, appId: string, versionId: string, clEntityId: string, wordListCreateObject: Models.WordListObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<number>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<number>;
    if (!callback) {
      return this.addSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, wordListCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as number);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addSubListWithHttpOperationResponse(azureRegion, appId, versionId, clEntityId, wordListCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as number;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a customizable prebuilt domain along with all of its models to this
   * application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainCreateBaseObject} prebuiltDomainObject A prebuilt
   * domain create object containing the name of the domain.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject): Promise<string[]>;
  addCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject, options: msRest.RequestOptionsBase): Promise<string[]>;
  addCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject, callback: msRest.ServiceCallback<string[]>): void;
  addCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string[]>): void;
  addCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainObject: Models.PrebuiltDomainCreateBaseObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string[]>;
    if (!callback) {
      return this.addCustomPrebuiltDomainWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addCustomPrebuiltDomainWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a custom prebuilt intent model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainModelCreateObject} prebuiltDomainModelCreateObject A
   * model object containing the name of the custom prebuilt intent and the name
   * of the domain to which this model belongs.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addCustomPrebuiltIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject): Promise<string>;
  addCustomPrebuiltIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addCustomPrebuiltIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addCustomPrebuiltIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addCustomPrebuiltIntent(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addCustomPrebuiltIntentWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addCustomPrebuiltIntentWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets custom prebuilt intents information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.IntentClassifier[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listCustomPrebuiltIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.IntentClassifier[]>;
  listCustomPrebuiltIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase): Promise<Models.IntentClassifier[]>;
  listCustomPrebuiltIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.IntentClassifier[]>): void;
  listCustomPrebuiltIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.IntentClassifier[]>): void;
  listCustomPrebuiltIntents(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.IntentClassifier[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.IntentClassifier[]>;
    if (!callback) {
      return this.listCustomPrebuiltIntentsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.IntentClassifier[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listCustomPrebuiltIntentsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.IntentClassifier[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Adds a custom prebuilt entity model to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PrebuiltDomainModelCreateObject} prebuiltDomainModelCreateObject A
   * model object containing the name of the custom prebuilt entity and the name
   * of the domain to which this model belongs.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addCustomPrebuiltEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject): Promise<string>;
  addCustomPrebuiltEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addCustomPrebuiltEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addCustomPrebuiltEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addCustomPrebuiltEntity(azureRegion: Models.AzureRegions, appId: string, versionId: string, prebuiltDomainModelCreateObject: Models.PrebuiltDomainModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addCustomPrebuiltEntityWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addCustomPrebuiltEntityWithHttpOperationResponse(azureRegion, appId, versionId, prebuiltDomainModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets all custom prebuilt entities information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listCustomPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.EntityExtractor[]>;
  listCustomPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityExtractor[]>;
  listCustomPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.EntityExtractor[]>): void;
  listCustomPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityExtractor[]>): void;
  listCustomPrebuiltEntities(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityExtractor[]>;
    if (!callback) {
      return this.listCustomPrebuiltEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listCustomPrebuiltEntitiesWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets all custom prebuilt models information of this application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.CustomPrebuiltModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  listCustomPrebuiltModels(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.CustomPrebuiltModel[]>;
  listCustomPrebuiltModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase): Promise<Models.CustomPrebuiltModel[]>;
  listCustomPrebuiltModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.CustomPrebuiltModel[]>): void;
  listCustomPrebuiltModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CustomPrebuiltModel[]>): void;
  listCustomPrebuiltModels(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CustomPrebuiltModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CustomPrebuiltModel[]>;
    if (!callback) {
      return this.listCustomPrebuiltModelsWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.CustomPrebuiltModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.listCustomPrebuiltModelsWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.CustomPrebuiltModel[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a prebuilt domain's models from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} domainName Domain name.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string): Promise<Models.OperationStatus>;
  deleteCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCustomPrebuiltDomain(azureRegion: Models.AzureRegions, appId: string, versionId: string, domainName: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteCustomPrebuiltDomainWithHttpOperationResponse(azureRegion, appId, versionId, domainName, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteCustomPrebuiltDomainWithHttpOperationResponse(azureRegion, appId, versionId, domainName, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Gets information about the hierarchical entity child model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.HierarchicalChildEntity} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.HierarchicalChildEntity} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string): Promise<Models.HierarchicalChildEntity>;
  getHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options: msRest.RequestOptionsBase): Promise<Models.HierarchicalChildEntity>;
  getHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, callback: msRest.ServiceCallback<Models.HierarchicalChildEntity>): void;
  getHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.HierarchicalChildEntity>): void;
  getHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.HierarchicalChildEntity>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.HierarchicalChildEntity>;
    if (!callback) {
      return this.getHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.HierarchicalChildEntity);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.HierarchicalChildEntity;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Renames a single child in an existing hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {HierarchicalChildModelUpdateObject}
   * hierarchicalChildModelUpdateObject Model object containing new name of the
   * hierarchical entity child.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject): Promise<Models.OperationStatus>;
  updateHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, hierarchicalChildModelUpdateObject: Models.HierarchicalChildModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, hierarchicalChildModelUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, hierarchicalChildModelUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a hierarchical entity extractor child from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} hChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string): Promise<Models.OperationStatus>;
  deleteHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hChildId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hChildId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Creates a single child in an existing hierarchical entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {HierarchicalChildModelCreateObject}
   * hierarchicalChildModelCreateObject A model object containing the name of the
   * new hierarchical child model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject): Promise<string>;
  addHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addHierarchicalEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, hierarchicalChildModelCreateObject: Models.HierarchicalChildModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hierarchicalChildModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addHierarchicalEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, hierarchicalChildModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Creates a single child in an existing composite entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {CompositeChildModelCreateObject} compositeChildModelCreateObject A
   * model object containing the name of the new composite child model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject): Promise<string>;
  addCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  addCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  addCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  addCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, compositeChildModelCreateObject: Models.CompositeChildModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.addCompositeEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, compositeChildModelCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addCompositeEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, compositeChildModelCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * Deletes a composite entity extractor child from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} cChildId The hierarchical entity extractor child ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string): Promise<Models.OperationStatus>;
  deleteCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntityChild(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, cChildId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteCompositeEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, cChildId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteCompositeEntityChildWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, cChildId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets information about the regex entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelGetRegexEntityInfosOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.RegexEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getRegexEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.RegexEntityExtractor[]>;
  getRegexEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelGetRegexEntityInfosOptionalParams): Promise<Models.RegexEntityExtractor[]>;
  getRegexEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.RegexEntityExtractor[]>): void;
  getRegexEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelGetRegexEntityInfosOptionalParams, callback: msRest.ServiceCallback<Models.RegexEntityExtractor[]>): void;
  getRegexEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelGetRegexEntityInfosOptionalParams, callback?: msRest.ServiceCallback<Models.RegexEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.RegexEntityExtractor[]>;
    if (!callback) {
      return this.getRegexEntityInfosWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.RegexEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getRegexEntityInfosWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.RegexEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Adds a regex entity model to the application version.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {RegexModelCreateObject} regexEntityExtractorCreateObj A model object
   * containing the name and regex pattern for the new regex entity extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject): Promise<string>;
  createRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  createRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityExtractorCreateObj: Models.RegexModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityExtractorCreateObj, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityExtractorCreateObj, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get information about the Pattern.Any entity models.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {ModelGetPatternAnyEntityInfosOptionalParams} [options] Optional
   * Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.PatternAnyEntityExtractor[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPatternAnyEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string): Promise<Models.PatternAnyEntityExtractor[]>;
  getPatternAnyEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelGetPatternAnyEntityInfosOptionalParams): Promise<Models.PatternAnyEntityExtractor[]>;
  getPatternAnyEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, callback: msRest.ServiceCallback<Models.PatternAnyEntityExtractor[]>): void;
  getPatternAnyEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options: Models.ModelGetPatternAnyEntityInfosOptionalParams, callback: msRest.ServiceCallback<Models.PatternAnyEntityExtractor[]>): void;
  getPatternAnyEntityInfos(azureRegion: Models.AzureRegions, appId: string, versionId: string, options?: Models.ModelGetPatternAnyEntityInfosOptionalParams, callback?: msRest.ServiceCallback<Models.PatternAnyEntityExtractor[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PatternAnyEntityExtractor[]>;
    if (!callback) {
      return this.getPatternAnyEntityInfosWithHttpOperationResponse(azureRegion, appId, versionId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.PatternAnyEntityExtractor[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPatternAnyEntityInfosWithHttpOperationResponse(azureRegion, appId, versionId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.PatternAnyEntityExtractor[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Adds a pattern.any entity extractor to the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {PatternAnyModelCreateObject} extractorCreateObject A model object
   * containing the name and explicit list for the new Pattern.Any entity
   * extractor.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createPatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject): Promise<string>;
  createPatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createPatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject, callback: msRest.ServiceCallback<string>): void;
  createPatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createPatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, extractorCreateObject: Models.PatternAnyModelCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createPatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, extractorCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createPatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, extractorCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getPrebuiltEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPrebuiltEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getClosedListEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getClosedListEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getClosedListEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getClosedListEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getClosedListEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getClosedListEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getClosedListEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getRegexEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getRegexEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getRegexEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getRegexEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getRegexEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getRegexEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getRegexEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getCompositeEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string): Promise<Models.EntityRole[]>;
  getCompositeEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getCompositeEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getCompositeEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getCompositeEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getCompositeEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCompositeEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPatternAnyEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getPatternAnyEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getPatternAnyEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getPatternAnyEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getPatternAnyEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getPatternAnyEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPatternAnyEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createPatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createPatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getHierarchicalEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string): Promise<Models.EntityRole[]>;
  getHierarchicalEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getHierarchicalEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getHierarchicalEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getHierarchicalEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getHierarchicalEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getHierarchicalEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get All Entity Roles for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity Id
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getCustomPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.EntityRole[]>;
  getCustomPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole[]>;
  getCustomPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getCustomPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole[]>): void;
  getCustomPrebuiltEntityRoles(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole[]>;
    if (!callback) {
      return this.getCustomPrebuiltEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCustomPrebuiltEntityRolesWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Create an entity role for an entity in the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity model ID.
   *
   * @param {EntityRoleCreateObject} entityRoleCreateObject An entity role object
   * containing the name of role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {string} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  createCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject): Promise<string>;
  createCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase): Promise<string>;
  createCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, callback: msRest.ServiceCallback<string>): void;
  createCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<string>): void;
  createCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, entityRoleCreateObject: Models.EntityRoleCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<string>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<string>;
    if (!callback) {
      return this.createCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as string);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, entityRoleCreateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as string;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get the explicit list of the pattern.any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ExplicitListItem[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getExplicitList(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.ExplicitListItem[]>;
  getExplicitList(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.ExplicitListItem[]>;
  getExplicitList(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.ExplicitListItem[]>): void;
  getExplicitList(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ExplicitListItem[]>): void;
  getExplicitList(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ExplicitListItem[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ExplicitListItem[]>;
    if (!callback) {
      return this.getExplicitListWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ExplicitListItem[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getExplicitListWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ExplicitListItem[];
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Add a new item to the explicit list for the Pattern.Any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {ExplicitListItemCreateObject} item The new explicit list item.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {number} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  addExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject): Promise<number>;
  addExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject, options: msRest.RequestOptionsBase): Promise<number>;
  addExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject, callback: msRest.ServiceCallback<number>): void;
  addExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<number>): void;
  addExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, item: Models.ExplicitListItemCreateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<number>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<number>;
    if (!callback) {
      return this.addExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, item, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as number);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, item, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as number;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets information of a regex entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity model ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.RegexEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.RegexEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getRegexEntityEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string): Promise<Models.RegexEntityExtractor>;
  getRegexEntityEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.RegexEntityExtractor>;
  getRegexEntityEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, callback: msRest.ServiceCallback<Models.RegexEntityExtractor>): void;
  getRegexEntityEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.RegexEntityExtractor>): void;
  getRegexEntityEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.RegexEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.RegexEntityExtractor>;
    if (!callback) {
      return this.getRegexEntityEntityInfoWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.RegexEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getRegexEntityEntityInfoWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.RegexEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates the regex entity model .
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity extractor ID.
   *
   * @param {RegexModelUpdateObject} regexEntityUpdateObject An object containing
   * the new entity name and regex pattern.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject): Promise<Models.OperationStatus>;
  updateRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, regexEntityUpdateObject: Models.RegexModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, regexEntityUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, regexEntityUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a regex entity model from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} regexEntityId The regex entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string): Promise<Models.OperationStatus>;
  deleteRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteRegexEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, regexEntityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteRegexEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, regexEntityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Gets information about the application version's Pattern.Any model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.PatternAnyEntityExtractor} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.PatternAnyEntityExtractor} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPatternAnyEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.PatternAnyEntityExtractor>;
  getPatternAnyEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.PatternAnyEntityExtractor>;
  getPatternAnyEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.PatternAnyEntityExtractor>): void;
  getPatternAnyEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.PatternAnyEntityExtractor>): void;
  getPatternAnyEntityInfo(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.PatternAnyEntityExtractor>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PatternAnyEntityExtractor>;
    if (!callback) {
      return this.getPatternAnyEntityInfoWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.PatternAnyEntityExtractor);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPatternAnyEntityInfoWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.PatternAnyEntityExtractor;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates the name and explicit list of a Pattern.Any entity model.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {PatternAnyModelUpdateObject} patternAnyUpdateObject An object
   * containing the explicit list of the Pattern.Any entity.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updatePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject): Promise<Models.OperationStatus>;
  updatePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updatePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, patternAnyUpdateObject: Models.PatternAnyModelUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updatePatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, entityId, patternAnyUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updatePatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, entityId, patternAnyUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Deletes a Pattern.Any entity extractor from the application.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string): Promise<Models.OperationStatus>;
  deletePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deletePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePatternAnyEntityModel(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deletePatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deletePatternAnyEntityModelWithHttpOperationResponse(azureRegion, appId, versionId, entityId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updatePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updatePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updatePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updatePrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updatePrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deletePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deletePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deletePrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deletePrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteClosedListEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteClosedListEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteRegexEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteRegexEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string): Promise<Models.EntityRole>;
  getCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} cEntityId The composite entity extractor ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCompositeEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, cEntityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteCompositeEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, cEntityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getPatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getPatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updatePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updatePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updatePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updatePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updatePatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updatePatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deletePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deletePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deletePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deletePatternAnyEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deletePatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deletePatternAnyEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string): Promise<Models.EntityRole>;
  getHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} hEntityId The hierarchical entity extractor ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteHierarchicalEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, hEntityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteHierarchicalEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, hEntityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get one entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId entity ID.
   *
   * @param {string} roleId entity role ID.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.EntityRole} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.EntityRole} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.EntityRole>;
  getCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.EntityRole>;
  getCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.EntityRole>): void;
  getCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.EntityRole>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.EntityRole>;
    if (!callback) {
      return this.getCustomEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.EntityRole);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCustomEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.EntityRole;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Update an entity role for a given entity
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role ID.
   *
   * @param {EntityRoleUpdateObject} entityRoleUpdateObject The new entity role.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject): Promise<Models.OperationStatus>;
  updateCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateCustomPrebuiltEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, entityRoleUpdateObject: Models.EntityRoleUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateCustomPrebuiltEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, entityRoleUpdateObject, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete an entity role.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The entity ID.
   *
   * @param {string} roleId The entity role Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string): Promise<Models.OperationStatus>;
  deleteCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteCustomEntityRole(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, roleId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteCustomEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteCustomEntityRoleWithHttpOperationResponse(azureRegion, appId, versionId, entityId, roleId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Get the explicit list of the pattern.any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity Id.
   *
   * @param {number} itemId The explicit list item Id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.ExplicitListItem} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.ExplicitListItem} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  getExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number): Promise<Models.ExplicitListItem>;
  getExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options: msRest.RequestOptionsBase): Promise<Models.ExplicitListItem>;
  getExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, callback: msRest.ServiceCallback<Models.ExplicitListItem>): void;
  getExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.ExplicitListItem>): void;
  getExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.ExplicitListItem>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.ExplicitListItem>;
    if (!callback) {
      return this.getExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.ExplicitListItem);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.ExplicitListItem;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Updates an explicit list item for a Pattern.Any entity.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The Pattern.Any entity extractor ID.
   *
   * @param {number} itemId The explicit list item ID.
   *
   * @param {ExplicitListItemUpdateObject} item The new explicit list item.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  updateExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject): Promise<Models.OperationStatus>;
  updateExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  updateExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  updateExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, item: Models.ExplicitListItemUpdateObject, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.updateExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, item, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, item, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

  /**
   * @summary Delete the explicit list item from the Pattern.any explicit list.
   *
   * @param {AzureRegions} azureRegion Supported Azure regions for Cognitive
   * Services endpoints. Possible values include: 'westus', 'westeurope',
   * 'southeastasia', 'eastus2', 'westcentralus', 'westus2', 'eastus',
   * 'southcentralus', 'northeurope', 'eastasia', 'australiaeast', 'brazilsouth'
   *
   * @param {string} appId The application ID.
   *
   * @param {string} versionId The version ID.
   *
   * @param {string} entityId The pattern.any entity id.
   *
   * @param {number} itemId The explicit list item which will be deleted.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback - The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Models.OperationStatus} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.OperationStatus} for more
   *                      information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {Response} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number): Promise<Models.OperationStatus>;
  deleteExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options: msRest.RequestOptionsBase): Promise<Models.OperationStatus>;
  deleteExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.OperationStatus>): void;
  deleteExplicitListItem(azureRegion: Models.AzureRegions, appId: string, versionId: string, entityId: string, itemId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.OperationStatus>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.OperationStatus>;
    if (!callback) {
      return this.deleteExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.bodyAsJson as Models.OperationStatus);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.deleteExplicitListItemWithHttpOperationResponse(azureRegion, appId, versionId, entityId, itemId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.bodyAsJson as Models.OperationStatus;
        return cb(err, result, data.request, data.response);
      });
    }
  }

}
